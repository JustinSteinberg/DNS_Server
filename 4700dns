#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, RCODE, MX, CNAME, TXT, NS


class Server:
    def __init__(self, root_ip, zone_file, port):
        self.root_ip = root_ip
        self.zone_file = zone_file #Zone file
        self.domain = ""
        
        self.unresolved_queries = {}
        
        self.zone_data = {   # EXAMPLES
            "SOA": None, # {'primary_name_server': 'dns1.example.com.'}
            "NS": {}, # {'example.com.': ['dns1.example.com.', 'dns2.example.com.'], 'sub.example.com.': ['ns2.example.com.']}
            "A": {}, #{'dns1.example.com.': ['10.0.1.1'], 'dns2.example.com.': ['10.0.1.2'], 'server1.example.com.': ['10.0.1.5'], 'server2.example.com.': ['10.0.1.6', '10.0.1.7', '10.0.1.8'], 'ns2.example.com.': ['10.0.2.1']
            "AAAA": {}, # {'ftp.example.com.': 'mislove.org.', 'mail.example.com.': 'server1.example.com.', 'mail2.example.com.': 'server2.example.com.', 'www.example.com.': 'server1.example.com.'}
            "CNAME": {}, # {'ftp.example.com.': 'mislove.org.', 'mail.example.com.': 'server1.example.com.', 'mail2.example.com.': 'server2.example.com.', 'www.example.com.': 'server1.example.com.'}
            "MX": [], # [{'priority': 10, 'mail_server': 'mail.example.com.'}, {'priority': 20, 'mail_server': 'mail2.example.com.'}]
            "TXT": {} #{'txt.example.com.': '"txttext"'}
        }
        
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr, message):
        self.log("Sending message:\n%s" % message)
        self.socket.sendto(message.pack(), addr)

    def load_zone_file(self):
        """Load and parse the zone file. Splits file up into DNS Records
        """
        self.log(f"Loading zone file: {self.zone_file}")

        try:
            zone_records = ""
            with open(self.zone_file, "r") as file:
                zone_records = RR.fromZone(file.read())

            self.log("Records:\n%s" % zone_records)

            for record in zone_records:
                # print("Record: ", record)
                # print("rname: ", record.rname)
                # print("rtype: ", record.rtype)
                # print("QTYPE: ", QTYPE[record.rtype])
                # print("rdata: ", record.rdata)

                rtype = QTYPE[record.rtype]
                rdata = record.rdata
                rname = str(record.rname)

                if rtype == "SOA":
                    self.domain = rname
                    self.log("Our domain: %s" % self.domain)

                    self.zone_data["SOA"] = {
                        "primary_name_server": str(rdata.mname),
                    }
                elif rtype == "NS":
                    # print("IN NS")
                    if rname not in self.zone_data["NS"]:
                        self.zone_data["NS"][rname] = []
                    self.zone_data["NS"][rname].append(str(rdata))
                    self.log(self.zone_data["NS"])
                    #print(self.zone_data["NS"])
                elif rtype == "A":
                    #print("In A")
                    #print("rname: ", rname)
                    #print("data: ", str(rdata))
                    if rname not in self.zone_data["A"]:
                        self.zone_data["A"][rname] = []
                    self.zone_data["A"][rname].append(str(rdata))
                elif rtype == "AAAA":
                    if rname not in self.zone_data["AAAA"]:
                        self.zone_data["AAAA"][rname] = []
                    self.zone_data["AAAA"][rname].append(str(rdata))
                elif rtype == "CNAME":
                    self.zone_data["CNAME"][rname] = str(rdata)
                elif rtype == "MX":
                    self.zone_data["MX"].append({"priority": rdata.preference, "mail_server": str(rdata.label)})
                elif rtype == "TXT":
                    self.zone_data["TXT"][rname] = str(rdata)

           # print(self.zone_data) # FOR DEBUGGING
        except Exception as e:
            self.log("Could not load zone file: %s" % e)

    # checks and returns the record data for any CNAMEs that match the domain
    def checkCNAMERecords(self, domain):
        record_data = self.zone_data["CNAME"].get(domain, "") # this will always return 1
       # print("IN CHECK")
        #print(record_data)
        return record_data


    # returns the record data (so the A records for the domain)
    def checkARecords(self, domain):
        record_data = self.zone_data["A"].get(domain, [])
        return record_data
    
    def check_is_authoritative(self, queried_domain):
        
        if queried_domain.endswith(self.domain):
            return True
        
        return False

    # def recur(self, sections, record_type, request, addr, round):
    #     if sections[0] == round:
    #         self.log(f"Forwarding query to root server: {self.root_ip}")
    #         self.log(f"Sending message from CLIENT TO ROOT:\n%s" % request)
    #         self.socket.sendto(request.pack(), (self.root_ip, 60053))
    #         self.socket.sendto(request.pack(), (self.root_ip, 60053))  # one more for robustness, we can handle it
    #         print("Client request header ID: ", request.header.id)
    #         self.unresolved_queries[request.header.id] = addr
    #         print(self.unresolved_queries)
    #     else:
    #         print("WORKING ON IT")



    def record_response(self, record_type, domain, request):
        """Generate a response to DNS queries. Currently only support A and MX records.
        """
        # Todo: Handle recursion with DNS flags also probably best to make these seperate functions and pass through the response to fill
        try:
            if record_type == "A":

                # check if there are a's that match with the domain
                # if there is, do the add answer for each of them in record data
                # if not, check if there is a cname for that
                # if there is, add it to the answer, then check for a's with that domain
                # if there is, add it to the answer
                # if not, send answer???
                response = request.reply()
                self.log("query domain: %s" % domain)
                record_data = self.checkARecords(domain)
                if not record_data:
                    altName = self.checkCNAMERecords(domain)
                    if altName == "":
                        self.log(f"No A records found for {domain}")

                        response.header.rcode = RCODE.NXDOMAIN
                        return response
                    else:
                        response.add_answer(RR(domain, QTYPE.CNAME, ttl=60, rdata=CNAME(altName)))
                        aForCNAME = self.checkARecords(altName)
                        for aRec in aForCNAME:
                            response.add_answer(RR(altName, QTYPE.A, ttl=60, rdata=A(aRec)))
                        return response
                else:
                    for ip in record_data:
                        #print(ip)
                        response.add_answer(RR(domain, QTYPE.A, rdata=A(ip), ttl=60))
                    return response

                # response = request.reply()
                # # Retrieve all A records for the domain
                # print("query domain: ", domain)
                # record_data = self.zone_data["A"].get(domain, [])
                # print("record_data: ", record_data)
                # # If there are no records, return NXDOMAIN
                # if not record_data:
                #     self.log(f"No A records found for {domain}")
                #
                #     response.header.rcode = RCODE.NXDOMAIN
                #     return response
                #
                # # Create a response and add all A records
                # response = request.reply()
                # for ip in record_data:
                #     print(ip)
                #     response.add_answer(RR(domain, QTYPE.A, rdata=A(ip), ttl=60))
                #
                # return response

            if record_type == "MX":
                # Retrieve all MX records for the domain
                #print("query domain: ", domain)
                record_data = self.zone_data["MX"]
                #print("record_data: ", record_data)
                # If there are no records, return NXDOMAIN
                if len(record_data) == 0:
                    self.log(f"No MX records found for {domain}")
                    response = request.reply()
                    response.header.rcode = RCODE.NXDOMAIN  # Todo: Is this correct???
                    return response

                # Create a response and add all MX records with their priorities and MX
                response = request.reply()
                for mx in record_data:
                    response.add_answer(RR(domain, QTYPE.MX, rdata=MX(mx["mail_server"], preference=mx["priority"]), ttl=60))

                return response

            if record_type == "TXT":
                #print("query domain: ", domain)
                record_data = self.zone_data["TXT"].get(domain, "")
                #print("record_data: ", record_data)
                if len(record_data) == 0:
                    self.log(f"No TXT records found for {domain}")
                    response = request.reply()
                    response.header.rcode = RCODE.NXDOMAIN  # Todo: Is this correct???
                    return response
                else:
                    response = request.reply()
                    response.add_answer(RR(domain, QTYPE.TXT, rdata=TXT(record_data.strip("""\""""))))
                    return response

            if record_type == "NS":
                response = request.reply()
               # print("query domain: ", domain)
                record_data = self.zone_data["NS"].get(domain, [])
                if len(record_data) == 0:
                    self.log(f"No NS records found for {domain}")
                    response.header.rcode = RCODE.NXDOMAIN  # Todo: Is this correct???
                    return response
                else:
                    for ns in record_data:
                        response.add_answer(RR(domain, QTYPE.NS, rdata=NS(ns)))
                        associated = self.checkARecords(ns)
                        for aRec in associated:
                            response.add_ar(RR(ns, QTYPE.A, rdata=A(aRec), ttl=60))
                    return response


        except Exception as e:
            self.log("Could not retrieve record for %s, record_type: %s, %s" % (domain, record_type, e))
            response = request.reply()
            response.header.rcode = RCODE.SERVFAIL
            return response        

        
    def recv(self, socket):
        data, addr = socket.recvfrom(65535)

        # Unpack the DNS request
        request = DNSRecord.parse(data)
        self.log("Received message:\n%s \nip: %s port: %d" % (request, addr[0], addr[1]))
        
        if addr[0] == self.root_ip:
            self.log("Response from root server received")
            # Forward the root server's response back to the original client
            self.log("Root response header ID: %s" % request.header.id)
            request.header.aa = 0  # Ensure the AA flag is unset
            request.header.ra = 1  # Set the RA flag (recursion available)
            original_client = self.unresolved_queries.pop(request.header.id, None)
            self.log("AFTER POP")
            self.log(str(self.unresolved_queries))
            if original_client:
                self.log("Sending message from ROOT back to Client:\n%s" % request)
                self.send(original_client, request)
            else:
                self.log("No matching client for this response")
            return

        
        if len(request.questions) > 1:
            response = request.reply()
            response.header.rcode = RCODE.SERVFAIL
            self.send(addr, response)
            return
             
        question = request.questions[0]
        domain = str(question.qname)
        record_type = QTYPE[question.qtype]
        
        self.log(f"Domain: {domain}")
        self.log(f"Type: {record_type}")


        #Check if we are authority
        if self.check_is_authoritative(domain):
            response = self.record_response(record_type, domain, request)
            response.header.aa = 1  # Ensure the AA flag set
            self.send(addr, response)
        else:
            # ASK ANOTHER DNS SERVER, we need to add cache later.
            # if we ask for the smallest domain (ex: is .ns to root), then the next until we get the orginal query domain
            # sections = domain.split(".")
            # self.recur(sections, record_type, request, addr, sections[len(sections)-1])


            self.log(f"Forwarding query to root server: {self.root_ip}")
            self.log(f"Sending message from CLIENT TO ROOT:\n%s" % request)
            self.socket.sendto(request.pack(), (self.root_ip, 60053))
            #self.socket.sendto(request.pack(), (self.root_ip, 60053)) # one more for robustness, we can handle it
            # self.socket.sendto(request.pack(), (self.root_ip, 60053))  # one more for robustness, we can handle it
            self.log("Client request header ID: %s" % request.header.id)
            self.unresolved_queries[request.header.id] = addr
            self.log("UNRESLOVED QUERY ADDED")
            self.log(str(self.unresolved_queries))

        
                
    def run(self):
        seq = 0
        
        self.load_zone_file()

        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)

        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    print(f"Root IP:  {args.root_ip}")
    print(f"Zone file provided: {args.zone}")
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
