#!/usr/bin/env -S python3 -u

import argparse, socket, time, select, sys
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, RCODE, MX, CNAME, TXT, NS

# THE CLASS THAT CONTROLS OUR DNS SERVER, ALL OPERATIONS ARE WITHIN THIS CLASS
class Server:

    # PURPOSE: To initialize our DNS server with the proper information and data structures to operate the DNS server.
    # SIG: 1st: the ip of the root server as a string, 2nd: path to our zone_file as a string,
        # 3rd: port to bind UDP to as int
    def __init__(self, root_ip, zone_file, port):
        self.root_ip = root_ip # ip of the root server
        self.zone_file = zone_file #Zone file
        self.domain = "" # domain we are authoritative over
        
        self.unresolved_queries = {} # here we will save our dns queries that we are awaiting responses

        # Here we will fill our zone data
        self.zone_data = {   # EXAMPLES
            "SOA": None, # {'primary_name_server': 'dns1.example.com.'}
            "NS": {}, # {'example.com.': ['dns1.example.com.', 'dns2.example.com.'], 'sub.example.com.': ['ns2.example.com.']}
            "A": {}, #{'dns1.example.com.': ['10.0.1.1'], 'dns2.example.com.': ['10.0.1.2'], 'server1.example.com.': ['10.0.1.5'], 'server2.example.com.': ['10.0.1.6', '10.0.1.7', '10.0.1.8'], 'ns2.example.com.': ['10.0.2.1']
            "AAAA": {}, # {'ftp.example.com.': 'mislove.org.', 'mail.example.com.': 'server1.example.com.', 'mail2.example.com.': 'server2.example.com.', 'www.example.com.': 'server1.example.com.'}
            "CNAME": {}, # {'ftp.example.com.': 'mislove.org.', 'mail.example.com.': 'server1.example.com.', 'mail2.example.com.': 'server2.example.com.', 'www.example.com.': 'server1.example.com.'}
            "MX": [], # [{'priority': 10, 'mail_server': 'mail.example.com.'}, {'priority': 20, 'mail_server': 'mail2.example.com.'}]
            "TXT": {} #{'txt.example.com.': '"txttext"'}
        }

        # here we will save recursive dns answers according to ttl
        self.cache = {} # (record type, domain -> response, time, ttl)

        # socket creation with timeout of 1 second
        s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        s.settimeout(1)
        self.socket = s
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)

    # PURPOSE: To log information about our DNS server to standard error
    # SIG: 1st: Message as a string we would like to log
    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    # PURPOSE: To send a DNS query or response to given address
    # SIG: 1st: a pair of ip and port like (ip, port), 2nd: DNSLib query or response we would like to send
    def send(self, addr, message):
        self.log("Sending message:\n%s" % message)
        self.socket.sendto(message.pack(), addr)

    # PURPOSE: To add the given query and response to our cache so that we could cache it later!
    # SIG: 1st: DNS response we would like to cache, 2nd: DNS query that corresponds to the response
    def addToCache(self, response, query):
        self.log("Adding to cache!")
        record_type = QTYPE[query.questions[0].qtype]
        domain = query.questions[0].qname
        time_added = time.time()

        # Getting TTL of records
        if len(response.rr) > 0:
            self.cache.update({(record_type, domain): (response, time_added, response.rr[0].ttl)})
        elif len(response.auth) > 0:
            self.cache.update({(record_type, domain): (response, time_added, response.auth[0].ttl)})
        elif len(response.ar) > 0:
            self.cache.update({(record_type, domain): (response, time_added, response.ar[0].ttl)})
        else:
            self.log("No point in caching, probably bailiwick") # no viable records in response
            return

        self.log(str(time_added))
        self.log("CACHE:\n")
        self.log(str(self.cache))
        self.respectCache() # Quickly gets rid of any 0 TTLs

    # PURPOSE: Sends the response of the client's query back to the client with necessary modifications
    # SIG: 1st: DNS response to send back, 2nd: a pair of ip and port like (ip, port),
        # 3rd: the client's original query's ID, 4th: the client's original query,
        # 5th: (optional) True or False boolean to know if we should cache this response
    def send_to_client(self, response, client_addr, original_query_id, original_query, toCache=True):
        """
        Sends the response back to the client with necessary modifications.
        """

        response.header.id = original_query_id
        response.questions = original_query.questions
        # setting correct headers, we aren't authoritative of the response and we used recursion
        response.header.ra = 1
        response.header.aa = 0
        response.header.tc = 0

        for ans in original_query.rr:
            response.add_answer(ans) # add any necessary answers to the query

        if toCache: # not to cache if optional param is set to false
            self.addToCache(response, original_query)
        self.respectCache()
        self.socket.sendto(response.pack(), client_addr) # send our response
        self.log(f"Response sent to client at {client_addr}.")

    # PURPOSE: To parse our zone file so we have all the proper information
    def load_zone_file(self):
        """Load and parse the zone file. Splits file up into DNS Records
        """
        self.log(f"Loading zone file: {self.zone_file}")

        try:
            with open(self.zone_file, "r") as file:
                zone_records = RR.fromZone(file.read())

            self.log("Records:\n%s" % zone_records)

            for record in zone_records:

                rtype = QTYPE[record.rtype]
                rdata = record.rdata
                rname = str(record.rname)

                if rtype == "SOA": # if we find the SOA
                    self.domain = rname
                    self.log("Our domain: %s" % self.domain)
                    self.zone_data["SOA"] = {
                        "primary_name_server": str(rdata.mname),
                    }

                elif rtype == "NS": # if we find a NS record
                    if rname not in self.zone_data["NS"]:
                        self.zone_data["NS"][rname] = []
                    self.zone_data["NS"][rname].append(str(rdata))
                    self.log(str(self.zone_data["NS"]))

                elif rtype == "A": # if we find an A record
                    if rname not in self.zone_data["A"]:
                        self.zone_data["A"][rname] = []
                    self.zone_data["A"][rname].append(str(rdata))

                elif rtype == "AAAA": # if we find an AAAA record
                    if rname not in self.zone_data["AAAA"]:
                        self.zone_data["AAAA"][rname] = []
                    self.zone_data["AAAA"][rname].append(str(rdata))

                elif rtype == "CNAME": # if we find an CNAME record
                    self.zone_data["CNAME"][rname] = str(rdata)

                elif rtype == "MX": # if we find an MX record
                    self.zone_data["MX"].append({"priority": rdata.preference, "mail_server": str(rdata.label)})

                elif rtype == "TXT": # if we find an TXT record
                    self.zone_data["TXT"][rname] = str(rdata)

        except Exception as e:
            self.log("Could not load zone file: %s" % e)

    # PURPOSE: checks and returns the record data for any CNAMEs that match the domain
    # SIG: 1st: The domain associated with the CNAME record we are looking for
    def checkCNAMERecords(self, domain):
        record_data = self.zone_data["CNAME"].get(domain, "") # this should always return 1 cname if we got here
        return record_data

    # PURPOSE: checks and returns the record data for any A records that match the domain
    # SIG: 1st: The domain associated with the A records we are looking for
    def checkARecords(self, domain):
        record_data = self.zone_data["A"].get(domain, [])
        return record_data

    # PURPOSE: To check if the given domain is one we are authoriative over
    # SIG: 1st: The domain we are questioning as a string
    def check_is_authoritative(self, queried_domain):
        return queried_domain.endswith(self.domain)

    # NOTE: Only use function when we are authoritative over the record
    # PURPOSE: To check and receive the record that is requested, if we don't have it, we send back a NXDOMAIN status.
    # SIG: 1st: Record type as a string, 2nd: domain associated with record, 3rd: dns request we are working on
        # RETURNS: Proper response for your query (because we were authoritative over your requested domain)
    def record_response(self, record_type, domain, request):
        try:
            if record_type == "A":

                response = request.reply()
                self.log("query domain: %s" % domain)
                record_data = self.checkARecords(domain)
                if not record_data: # We do not have the direct A record
                    altName = self.checkCNAMERecords(domain) # do we have another name for that domain?
                    if altName == "":
                        # We have no records for ya.
                        self.log(f"No A records found for {domain}")
                        response.header.rcode = RCODE.NXDOMAIN
                        return response
                    else:
                        # We found another name for your requested domain, here are your A records for that name.
                        response.add_answer(RR(domain, QTYPE.CNAME, ttl=60, rdata=CNAME(altName)))
                        aForCNAME = self.checkARecords(altName) # gets a records for CNAME
                        for aRec in aForCNAME:
                            response.add_answer(RR(altName, QTYPE.A, ttl=60, rdata=A(aRec)))
                        return response
                else:
                    for ip in record_data: # we found your A records :) adding to ur response
                        #print(ip)
                        response.add_answer(RR(domain, QTYPE.A, rdata=A(ip), ttl=60))
                    return response


            if record_type == "MX":
                # Retrieve all MX records for the domain
                record_data = self.zone_data["MX"]
                # If there are no records, return NXDOMAIN
                if len(record_data) == 0:
                    self.log(f"No MX records found for {domain}")
                    response = request.reply()
                    response.header.rcode = RCODE.NXDOMAIN
                    return response

                # Create a response and add all MX records with their priorities and MX
                response = request.reply()
                for mx in record_data:
                    response.add_answer(RR(domain, QTYPE.MX, rdata=MX(mx["mail_server"], preference=mx["priority"]), ttl=60))
                return response

            if record_type == "TXT":
                # get all txt records for requested domain
                record_data = self.zone_data["TXT"].get(domain, "")
                if len(record_data) == 0: # if we found no txt records, u get a NXDOMAIN
                    self.log(f"No TXT records found for {domain}")
                    response = request.reply()
                    response.header.rcode = RCODE.NXDOMAIN
                    return response
                else:
                    # here are your TXT Records
                    response = request.reply()
                    response.add_answer(RR(domain, QTYPE.TXT, rdata=TXT(record_data.strip("""\"""")))) # sanitizing txt
                    return response

            if record_type == "NS":
                response = request.reply()
                # get all NS records for your requested domain
                record_data = self.zone_data["NS"].get(domain, [])
                if len(record_data) == 0: # no NS records found, u get NXDOMAIN
                    self.log(f"No NS records found for {domain}")
                    response.header.rcode = RCODE.NXDOMAIN
                    return response
                else:
                    for ns in record_data: # adding your NS records and any associated A records :)
                        response.add_answer(RR(domain, QTYPE.NS, rdata=NS(ns)))
                        associated = self.checkARecords(ns)
                        for aRec in associated:
                            response.add_ar(RR(ns, QTYPE.A, rdata=A(aRec), ttl=60))
                    return response

        except Exception as e:
            self.log("Could not retrieve record for %s, record_type: %s, %s" % (domain, record_type, e))
            response = request.reply()
            response.header.rcode = RCODE.SERVFAIL # yeah that record type makes no sense, sorry! u get SERVFAIL
            return response        

    # PURPOSE:
    #         Send DNS Query to the next server and adds the query to the unresolved_queries list.
    #         We add a timestamp to unresolved queries for later usage.
    #         We also keep track of the original clients address, the original query id, the type
    #         of record its requesting, and a copy of the query itself.
    #
    # SIG: 1st: domain for DNS query. Below are optional
        # 2nd: Record type as a string
        # 3rd: Next server to ask the query for as an ip string
        # 4th: original client's address as a pair: (ip, port)
        # 5th: original client's Query's ID as int
        # 6th: original client's Query
    def send_dns_query(self, domain, record_type="A", next_server=None, client_addr=None, original_query_id=None, original_query=None):

        self.retransmit()
        if not next_server: # we don't know who the next server is! sending back a SERVFAIL
            self.log("No root server provided. Returning SERVFAIL.")
            response = DNSRecord(DNSHeader(qr=1, rcode=RCODE.SERVFAIL))
            response.add_question(DNSRecord.question(domain, record_type))
            response.header.id = original_query_id
            self.socket.sendto(response.pack(), client_addr)
            return

        self.log(f"Starting recursive resolution for {domain} on server {next_server} for {str(original_query_id)}")

        # Create and send the DNS query
        query = DNSRecord.question(domain, record_type)
        query_data = query.pack()

        if original_query is None:
            original_query = query

        # Track the query metadata
        message_id = query.header.id
        self.log(str(original_query_id) + " vs " + str(message_id))
        self.unresolved_queries[message_id] = {
            "client_addr": client_addr,
            "original_query_id": original_query_id,
            "domain": domain,
            "record_type": record_type,
            "timestamp": time.time(),
            "original_query": original_query,
            "next_server": next_server,
            "retries": 0,
            "query_data" : query_data
        }
        
        self.log(f"Query sent to {next_server} for {domain} (ID: {query.header.id})")
        
        self.socket.sendto(query_data, (next_server, 60053)) # sending query to next hop

    # PURPOSE: Sends a SERVFAIL response back to the client.
    # SIG: 1st: record type as a string, 2nd: original client's address as a pair: (ip, port),
        # 3rd: original client's Query's ID
    def send_servfail_to_client(self, record_type, client_addr, original_query_id):

        if record_type not in QTYPE: # just double-checking if this is the reason we got a servfail
            self.log(f"Invalid record type: {record_type}.")

        response = DNSRecord(DNSHeader(qr=1, rcode=RCODE.SERVFAIL))
        #self.log("Example of servfail:")
        #self.log(str(response))
        response.header.id = original_query_id
        self.socket.sendto(response.pack(), client_addr)
        self.log(f"SERVFAIL response sent to client at {client_addr}.")

    # PURPOSE: Decides the next server we need to send our QUERY to based on the given response.
    # SIG: 1st: DNS response we were given that we know we have another hop to go
        # 2nd: The domain associated with the record
        # 3rd: Record type as a string
        # 4th: original client's address as a pair: (ip, port),
        # 5th:  original client's Query's ID
        # 6th: original client's Query
    def query_next_server(self, response, domain, record_type, client_addr, original_query_id, original_query):
        a_records_answer = self.find_records(response.ar, QTYPE.A) # get the A records
        next_servers = [str(record.rdata) for record in a_records_answer] # look for our possible hops in those A records
        
        if next_servers:
            # Loop through all A records and send queries to each server
            for server in next_servers:
                self.log(f"Querying next server: {server} for {domain} for record type {record_type}.")
                self.send_dns_query(domain, record_type, server, client_addr, original_query_id, original_query)
        else:
            # If no A records, fall back to NS records
            nameserver_records = self.find_records(response.auth, QTYPE.NS)
            nameserver_data = [str(record.rdata) for record in nameserver_records]
            
            if nameserver_data: # we have a NS record we can depend on for our next hop
                self.log("Resolving NS records to IP addresses for further queries.")
                # Query the root server to resolve the NS names into IPs
                for ns in nameserver_data:
                    self.send_dns_query(ns, "A", self.root_ip, client_addr, original_query_id, original_query)
            else: # no next hop
                self.log("No servers left to query. Returning SERVFAIL.")
                self.send_servfail_to_client(record_type, client_addr, original_query_id)

    # PURPOSE: """
    #         Function to find DNS records of a specific type and domain in
    #         a specific section (ANSWER, AUTHORITATIVE, ADDITIONAL).
    #         If domain is not provided then return all records of that type in
    #         corresponding section. reecords is a list of DNS records to search.
    #         rtype is the record type to search for (e.g., QTYPE.A, QTYPE.MX) and
    #         the domain is the name to match against the records against.
    #         """
    # SIG: 1st: records to search through, 2nd: Record type you are looking for, 3rd: Optional! Domain to match records to
    def find_records(self, records, rtype, domain=None):
        matching_records = []
        for record in records:
            if record.rtype == rtype:
                if domain is None or str(record.rname) == domain:
                    matching_records.append(record)
        return matching_records

    # PURPOSE: To check the section of the DNS response and make sure the domain is authoritative over the records
    # SIG: 1st: Records to filter, 2nd: Domain that qualifies the records as keepers
    def filter_section(self, records, domain):
        return [record for record in records if str(record.rname).endswith(domain)]

    # PURPOSE: To filter out any records in our dns response that DO NOT pass the bailiwick test
    # SIG: 1st: Response to filter through, 2nd: domain as a string we are checking authority for in the records
    def bailiwickFilter(self, response, domain):
        self.respectCache()
        self.retransmit()
        self.log("Filtering response for bailiwick of domain: " + domain)

        # Filter answer, additional, and authority sections
        response.rr = self.filter_section(response.rr, domain)  # Answer section
        response.ar = self.filter_section(response.ar, domain)  # Additional section
        response.auth = self.filter_section(response.auth, domain)  # Authority section

        self.log(f"Filtered response:\n{response}")
        return response

    # NOTE: ONLY USE IF U KNOW ITS A RESPONSE FROM A DNS SERVER AND NOT A CLIENT
    # PURPOSE: Handles responses from other DNS servers, handling each record type.
    # SIG: 1st: The raw data from the DNS reserver who sent us this response
    def handle_other_DNS_server_response(self, data):
        self.respectCache()
        self.retransmit()
        self.log("Processing response from upstream server")

        # Parse the DNS response
        response = DNSRecord.parse(data)
        self.log(f"DNS SERVER RESPONSE: {response}")
        message_id = response.header.id

        # Verify the message ID is expected
        if message_id not in self.unresolved_queries:
            self.log(f"Unexpected response ID {message_id}. Ignoring.")
            return

        # Extract query metadata
        query_metadata = self.unresolved_queries.pop(message_id)
        client_addr = query_metadata["client_addr"]
        original_query_id = query_metadata["original_query_id"]
        domain = query_metadata["domain"]
        record_type = query_metadata["record_type"]
        original_query = query_metadata["original_query"]

        # Check if the response is authoritative
        cname_records = self.find_records(response.rr, QTYPE.CNAME, domain)
        
        if response.header.aa and len(cname_records) == 0:
            self.log("Authoritative response received. Forwarding to client.")
            # doing bailiwick checking here, hopefully we didn't recur as much for bailiwicks
            response = self.bailiwickFilter(response, domain)
            self.log("about to send answer for " + str(original_query_id))
            self.send_to_client(response, client_addr, original_query_id, original_query)
            return
        elif response.header.aa and len(cname_records) > 0:
            record_type = "CNAME"
            
        # Process response based on the record type
        #Here we get all the A records in the additional section 
        #If there are A records in the additional section WITH THE SPECIFIC DOMAIN, send to client
        #OTHERWISE we go through all the other A Records 
        if record_type == "A":
            self.log("Handling A record.")
            a_records = self.find_records(response.ar, QTYPE.A, domain)
            
            if a_records:
                self.log(f"A records for {domain} found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log(f"No A records for {domain}. Querying next server.")
                self.query_next_server(response, domain, record_type, client_addr, original_query_id, original_query)
                
        #there might be an issue with CNAME records in ANSWER section because we are replacing the ORIGINAL DOMAIN NAME 
        # WITH THE CNAME ALIAS IN THE QUESTION SECTION. So when we send back the RESPONSE to the client, the QUESTION
        # SECTION now has the alias in the Question, not the original domain. I think we need to PRESERVE 
        # the ORIGINAL domian somehow while also using the CNAME name for performing THE DNS QUERY
        
        #THE ABOVE WAS SOLVED BY PASSING THE ORIGINAL QUERY THROUGHOUT THE CALLS TO BE SAVED IN
        #unresolved_queries which could be used to update the Question Section with the appropriate domain
        elif record_type == "CNAME":
            self.log("Handling CNAME record.")
            cname_records = self.find_records(response.rr, QTYPE.CNAME, domain)
            
            if cname_records:
                resolved_name = str(cname_records[0].rdata)
                self.log(f"Resolving CNAME: {domain} -> {resolved_name}")
                # response.add_answer(RR("example.com", rtype="A", ttl=300, rdata=A("192.0.2.1")))
                original_query.add_answer(RR(domain, QTYPE.CNAME, ttl=300, rdata=CNAME(resolved_name)))
                self.send_dns_query(resolved_name, "A", self.root_ip, client_addr, original_query_id, original_query)
            else:
                self.log("No CNAME records found. Returning SERVFAIL.")
                self.send_servfail_to_client(record_type, client_addr, original_query_id)

        elif record_type == "MX":
            self.log("Handling MX record.")
            mx_records = self.find_records(response.rr, QTYPE.MX, domain)
            
            if mx_records:
                self.log(" MX records found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log("No MX records found. Querying next server.")
                self.query_next_server(response, domain, record_type, client_addr, original_query_id, original_query)

        elif record_type == "TXT":
            self.log("Handling TXT record.")
            txt_records = self.find_records(response.rr, QTYPE.TXT, domain)
            if txt_records:
                self.log(" TXT records found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log("No TXT records found. Querying next server.")
                self.query_next_server(response, domain, record_type, client_addr, original_query_id, original_query)

        elif record_type == "NS":
            self.log("Handling NS record.")
            ns_records = [record for record in response.auth if record.rtype == QTYPE.NS]
            additional_a_records = [record for record in response.ar if record.rtype == QTYPE.A]
            if ns_records and additional_a_records:
                self.log("NS records with additional A records found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log("Resolving NS records to IP addresses.")
                for ns in ns_records:
                    self.send_dns_query(str(ns.rdata), "A", self.root_ip, client_addr, original_query_id, original_query)

        else:
            self.log(f"Unhandled record type {record_type}. Returning SERVFAIL.")
            self.log(record_type)
            self.send_servfail_to_client(record_type, client_addr, original_query_id)


    # PURPOSE: Handles requests from clients, so ONLY USE THIS IF U KNOW ITS FROM A CLIENT
    # SIG: 1st: raw data from the client, 2nd: original client's address as a pair: (ip, port),
    def handle_client_query(self, data, addr):
        self.respectCache()
        self.retransmit()
        self.log("Client Query")
        # Parse and handle a client DNS query
        request = DNSRecord.parse(data)
        question = request.questions[0]
        domain = str(question.qname)
        record_type = QTYPE[question.qtype]
        self.log(f"Received query for {domain} (Type: {record_type}) from {addr} as ID: {request.header.id}")

        if self.check_is_authoritative(domain): # If we get an authoritative response, we have the answer!
            # Generate an authoritative response
            response = self.record_response(record_type, domain, request)
            response.header.id = request.header.id
            self.log(f"Sending authoritative response to {addr}")
            self.socket.sendto(response.pack(), addr)
        else:
            # lets check our cache really quick to see if we can solve this easy
            res = self.cache.get((record_type, question.qname), None) # CHECKS CACHE
            if res is None: # Nothing useful in cache, time to do recursive answering
                # Forward query to the root server to resolve an appropriate answer
                self.log(f"Forwarding query for {domain} to root server as ID: {request.header.id}")
                self.send_dns_query(domain, record_type, self.root_ip, addr, request.header.id, request)
            else:
                self.log("CACHE HIT")
                self.send_to_client(res[0], addr, request.header.id, request, False)

    # PURPOSE: Cleans up the cache by removing entries that have expired based on their TTL.
    # NOTE:  The cache format is: self.cache = { (record_type, domain): (response, time_added, ttl) }
    def respectCache(self):
        self.log("Running respectCache to remove expired entries")

        # List of keys to delete (to avoid modifying the dictionary during iteration)
        keys_to_delete = []

        # Iterate through the cache
        for rec, (response, time_added, ttl) in self.cache.items():
            # Check if the current time exceeds the TTL
            if time.time() - time_added > ttl:
                self.log(f"Cache entry expired for {rec}. Removing from cache.")
                keys_to_delete.append(rec)

        # Remove expired entries
        for key in keys_to_delete:
            del self.cache[key]

        self.log("Cache cleanup completed.")

    # PURPOSE: Checks our unresolved queries and if we have one that is outgoing for long than a second, retransmit it
        # as it could have been dropped. If we have retransmitted 5 times already, send back to client a SERVFAIL
    def retransmit(self):
        for message_id in list(self.unresolved_queries.keys()):
            focused = self.unresolved_queries[message_id]

            if (time.time() - focused["timestamp"]) > 1: # are we outgoing for more than a second?
                if focused["retries"] < 5:
                    # Retransmit
                    self.log("RETRANSMITTING: Query sent to " + str(focused["next_server"]) +
                             " for " + str(focused["domain"]) + " ID: " + str(message_id))
                    focused["retries"] += 1
                    self.socket.sendto(focused["query_data"], (focused["next_server"], 60053))
                    focused["timestamp"] = time.time()
                else:
                    # We have retransmitted 5 times already :(
                    self.log("WE SHOULD THROW THIS OUT and send a fail back FOR:" + str())
                    self.unresolved_queries.pop(message_id)
                    self.send_servfail_to_client(focused["record_type"], focused["client_addr"], focused["original_query_id"])

    # PURPOSE: To recv information from the given socket.
    # SIG: The socket we will recv from
    def recv(self, sock):
        # Handle incoming requests and upstream responses
        try:
            data, addr = sock.recvfrom(65535)
            if addr[1] == 60053: # if we received from a port 60053, its another DNS server, not a client
                self.handle_other_DNS_server_response(data)
            else:  # Client query
                self.handle_client_query(data, addr)
        except Exception as e:
            # usually happens due to timeout, which is okay and try again later! Check retransmits while we are here.
            self.log(str(e))
            self.retransmit()

    # PURPOSE: Starts off our DNS Server! Run this first!
    def run(self):
        
        self.load_zone_file() # lets parse our zone file so we can get to know our records
        socks = select.select([self.socket], [], [])[0] # get our socket
        for conn in socks:
            while True: # the main operations! (recv will handle all responses and decide the sends)!
                    self.retransmit()
                    self.recv(conn)
                    self.respectCache()
                    self.retransmit()


        return

# THE BIG MAIN FUNCTION TO START EVERYTHING
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data') # set up our arg parser

    # add args
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args() # parse args

    # print important info
    print(f"Root IP:  {args.root_ip}")
    print(f"Zone file provided: {args.zone}")

    sender = Server(args.root_ip, args.zone, args.port) # set up our DNS server
    sender.run() # LETS RUN OUR DNS SERVER WOOO!
