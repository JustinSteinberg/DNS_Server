#!/usr/bin/env -S python3 -u

import argparse, socket, time, json, select, struct, sys, math
from dnslib import DNSRecord, DNSHeader, RR, QTYPE, A, RCODE, MX, CNAME, TXT, NS


class Server:
    def __init__(self, root_ip, zone_file, port):
        self.root_ip = root_ip
        self.zone_file = zone_file #Zone file
        self.domain = ""
        
        self.unresolved_queries = {}
        
        self.zone_data = {   # EXAMPLES
            "SOA": None, # {'primary_name_server': 'dns1.example.com.'}
            "NS": {}, # {'example.com.': ['dns1.example.com.', 'dns2.example.com.'], 'sub.example.com.': ['ns2.example.com.']}
            "A": {}, #{'dns1.example.com.': ['10.0.1.1'], 'dns2.example.com.': ['10.0.1.2'], 'server1.example.com.': ['10.0.1.5'], 'server2.example.com.': ['10.0.1.6', '10.0.1.7', '10.0.1.8'], 'ns2.example.com.': ['10.0.2.1']
            "AAAA": {}, # {'ftp.example.com.': 'mislove.org.', 'mail.example.com.': 'server1.example.com.', 'mail2.example.com.': 'server2.example.com.', 'www.example.com.': 'server1.example.com.'}
            "CNAME": {}, # {'ftp.example.com.': 'mislove.org.', 'mail.example.com.': 'server1.example.com.', 'mail2.example.com.': 'server2.example.com.', 'www.example.com.': 'server1.example.com.'}
            "MX": [], # [{'priority': 10, 'mail_server': 'mail.example.com.'}, {'priority': 20, 'mail_server': 'mail2.example.com.'}]
            "TXT": {} #{'txt.example.com.': '"txttext"'}
        }
        
        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.socket.bind(("0.0.0.0", port))
        self.port = self.socket.getsockname()[1]

        self.log("Bound to port %d" % self.port)

    def log(self, message):
        sys.stderr.write(message + "\n")
        sys.stderr.flush()

    def send(self, addr, message):
        self.log("Sending message:\n%s" % message)
        self.socket.sendto(message.pack(), addr)
        
    def send_to_client(self, response, client_addr, original_query_id, original_query):
        """
        Sends the response back to the client with necessary modifications.
        """
        response.header.id = original_query_id
        response.questions = original_query.questions
        response.header.ra = 1
        response.header.aa = 0
        response.header.tc = 0
        self.socket.sendto(response.pack(), client_addr)
        self.log(f"Response sent to client at {client_addr}.")

    def load_zone_file(self):
        """Load and parse the zone file. Splits file up into DNS Records
        """
        self.log(f"Loading zone file: {self.zone_file}")

        try:
            zone_records = ""
            with open(self.zone_file, "r") as file:
                zone_records = RR.fromZone(file.read())

            self.log("Records:\n%s" % zone_records)

            for record in zone_records:
                # print("Record: ", record)
                # print("rname: ", record.rname)
                # print("rtype: ", record.rtype)
                # print("QTYPE: ", QTYPE[record.rtype])
                # print("rdata: ", record.rdata)

                rtype = QTYPE[record.rtype]
                rdata = record.rdata
                rname = str(record.rname)

                if rtype == "SOA":
                    self.domain = rname
                    self.log("Our domain: %s" % self.domain)

                    self.zone_data["SOA"] = {
                        "primary_name_server": str(rdata.mname),
                    }
                elif rtype == "NS":
                    # print("IN NS")
                    if rname not in self.zone_data["NS"]:
                        self.zone_data["NS"][rname] = []
                    self.zone_data["NS"][rname].append(str(rdata))
                    self.log(self.zone_data["NS"])
                    #print(self.zone_data["NS"])
                elif rtype == "A":
                    #print("In A")
                    #print("rname: ", rname)
                    #print("data: ", str(rdata))
                    if rname not in self.zone_data["A"]:
                        self.zone_data["A"][rname] = []
                    self.zone_data["A"][rname].append(str(rdata))
                elif rtype == "AAAA":
                    if rname not in self.zone_data["AAAA"]:
                        self.zone_data["AAAA"][rname] = []
                    self.zone_data["AAAA"][rname].append(str(rdata))
                elif rtype == "CNAME":
                    self.zone_data["CNAME"][rname] = str(rdata)
                elif rtype == "MX":
                    self.zone_data["MX"].append({"priority": rdata.preference, "mail_server": str(rdata.label)})
                elif rtype == "TXT":
                    self.zone_data["TXT"][rname] = str(rdata)

           # print(self.zone_data) # FOR DEBUGGING
        except Exception as e:
            self.log("Could not load zone file: %s" % e)

    # checks and returns the record data for any CNAMEs that match the domain
    def checkCNAMERecords(self, domain):
        record_data = self.zone_data["CNAME"].get(domain, "") # this will always return 1
       # print("IN CHECK")
        #print(record_data)
        return record_data


    # returns the record data (so the A records for the domain)
    def checkARecords(self, domain):
        record_data = self.zone_data["A"].get(domain, [])
        return record_data
    
    def check_is_authoritative(self, queried_domain):
        
        if queried_domain.endswith(self.domain):
            return True
        
        return False
    
    def is_authoritative(self, response):
          # Parse the response using dnslib
        dns_record = DNSRecord.parse(response)
        
        # Check the AA (Authoritative Answer) flag
        return dns_record.header.aa


    def record_response(self, record_type, domain, request):
        """Generate a response to DNS queries. Currently only support A and MX records.
        """
        # Todo: Handle recursion with DNS flags also probably best to make these seperate functions and pass through the response to fill
        try:
            if record_type == "A":

                # check if there are a's that match with the domain
                # if there is, do the add answer for each of them in record data
                # if not, check if there is a cname for that
                # if there is, add it to the answer, then check for a's with that domain
                # if there is, add it to the answer
                # if not, send answer???
                response = request.reply()
                self.log("query domain: %s" % domain)
                record_data = self.checkARecords(domain)
                if not record_data:
                    altName = self.checkCNAMERecords(domain)
                    if altName == "":
                        self.log(f"No A records found for {domain}")

                        response.header.rcode = RCODE.NXDOMAIN
                        return response
                    else:
                        response.add_answer(RR(domain, QTYPE.CNAME, ttl=60, rdata=CNAME(altName)))
                        aForCNAME = self.checkARecords(altName)
                        for aRec in aForCNAME:
                            response.add_answer(RR(altName, QTYPE.A, ttl=60, rdata=A(aRec)))
                        return response
                else:
                    for ip in record_data:
                        #print(ip)
                        response.add_answer(RR(domain, QTYPE.A, rdata=A(ip), ttl=60))
                    return response


            if record_type == "MX":
                # Retrieve all MX records for the domain
                #print("query domain: ", domain)
                record_data = self.zone_data["MX"]
                #print("record_data: ", record_data)
                # If there are no records, return NXDOMAIN
                if len(record_data) == 0:
                    self.log(f"No MX records found for {domain}")
                    response = request.reply()
                    response.header.rcode = RCODE.NXDOMAIN  # Todo: Is this correct???
                    return response

                # Create a response and add all MX records with their priorities and MX
                response = request.reply()
                for mx in record_data:
                    response.add_answer(RR(domain, QTYPE.MX, rdata=MX(mx["mail_server"], preference=mx["priority"]), ttl=60))

                return response

            if record_type == "TXT":
                #print("query domain: ", domain)
                record_data = self.zone_data["TXT"].get(domain, "")
                #print("record_data: ", record_data)
                if len(record_data) == 0:
                    self.log(f"No TXT records found for {domain}")
                    response = request.reply()
                    response.header.rcode = RCODE.NXDOMAIN  # Todo: Is this correct???
                    return response
                else:
                    response = request.reply()
                    response.add_answer(RR(domain, QTYPE.TXT, rdata=TXT(record_data.strip("""\""""))))
                    return response

            if record_type == "NS":
                response = request.reply()
               # print("query domain: ", domain)
                record_data = self.zone_data["NS"].get(domain, [])
                if len(record_data) == 0:
                    self.log(f"No NS records found for {domain}")
                    response.header.rcode = RCODE.NXDOMAIN  # Todo: Is this correct???
                    return response
                else:
                    for ns in record_data:
                        response.add_answer(RR(domain, QTYPE.NS, rdata=NS(ns)))
                        associated = self.checkARecords(ns)
                        for aRec in associated:
                            response.add_ar(RR(ns, QTYPE.A, rdata=A(aRec), ttl=60))
                    return response


        except Exception as e:
            self.log("Could not retrieve record for %s, record_type: %s, %s" % (domain, record_type, e))
            response = request.reply()
            response.header.rcode = RCODE.SERVFAIL
            return response        


    def send_dns_query(self, domain, record_type="A", next_server=None, client_addr=None, original_query_id=None, original_query=None):
        """
        Send DNS Query to the next server and adds the query to the unresolved_queries list.
        We add a timestamp to unresolved queries for later usage.
        We also keep track of the original clients address, the original query id, the type
        of record its requesting, and a copy of the query itself.
        """
        if not next_server:
            self.log("No root server provided. Returning SERVFAIL.")
            response = DNSRecord(DNSHeader(qr=1, rcode=RCODE.SERVFAIL))
            response.add_question(DNSRecord.question(domain, record_type))
            response.header.id = original_query_id
            self.socket.sendto(response.pack(), client_addr)
            return

        self.log(f"Starting recursive resolution for {domain} on server {next_server}")

        # Create and send the DNS query
        query = DNSRecord.question(domain, record_type)
        query_data = query.pack()

        if original_query is None:
            original_query = query

        # Track the query metadata
        message_id = query.header.id
        self.unresolved_queries[message_id] = {
            "client_addr": client_addr,
            "original_query_id": original_query_id,
            "domain": domain,
            "record_type": record_type,
            "timestamp": time.time(),
            "original_query": original_query,
        }
        
        self.log(f"Query sent to {next_server} for {domain} (ID: {query.header.id})")
        
        self.socket.sendto(query_data, (next_server, 60053))
        
    def send_servfail_to_client(self, domain, record_type, client_addr, original_query_id):
        """
        Sends a SERVFAIL response to the client.
        """
        response = DNSRecord(DNSHeader(qr=1, rcode=RCODE.SERVFAIL))
        response.add_question(DNSRecord.question(domain, record_type))
        response.header.id = original_query_id
        self.socket.sendto(response.pack(), client_addr)
        self.log(f"SERVFAIL response sent to client at {client_addr}.")
        
    def query_next_server(self, response, domain, record_type, client_addr, original_query_id, original_query):
        """
        Gets the next server we need to send our QUERY to based on the response.
        """
        a_records_answer = self.find_records(response.ar, QTYPE.A)
        next_servers = [str(record.rdata) for record in a_records_answer]
        
        if next_servers:
            # Loop through all A records and send queries to each server
            for server in next_servers:
                self.log(f"Querying next server: {server} for {domain} for record type {record_type}.")
                self.send_dns_query(domain, record_type, server, client_addr, original_query_id, original_query)
        else:
            # If no A records, fall back to NS records
            nameserver_records = self.find_records(response.auth, QTYPE.NS)
            nameserver_data = [str(record.rdata) for record in nameserver_records]
            
            if nameserver_data:
                self.log("Resolving NS records to IP addresses for further queries.")
                # Query the root server to resolve the NS names into IPs
                for ns in nameserver_data:
                    self.send_dns_query(ns, "A", self.root_ip, client_addr, original_query_id, original_query)
            else:
                self.log("No servers left to query. Returning SERVFAIL.")
                self.send_servfail_to_client(domain, record_type, client_addr, original_query_id)
                
    def find_records(self, records, rtype, domain=None):
        """
        Function to find DNS records of a specific type and domain in 
        a specific section (ANSWER, AUTHORITATIVE, ADDITIONAL).
        If domain is not provided then return all records of that type in 
        corresponding section. reecords is a list of DNS records to search.
        rtype is the record type to search for (e.g., QTYPE.A, QTYPE.MX) and 
        the domain is the name to match against the records against.
        """
        
        matching_records = []
        for record in records:
            if record.rtype == rtype:
                if domain is None or str(record.rname) == domain:
                    matching_records.append(record)
        return matching_records

    def handle_other_DNS_server_response(self, data):
        """
        Handles responses from other DNS servers, handling each record type.
        """
        self.log("Processing response from upstream server")

        # Parse the DNS response
        response = DNSRecord.parse(data)
        self.log(f"DNS SERVER RESPONSE: {response}")
        message_id = response.header.id

        # Verify the message ID is expected
        if message_id not in self.unresolved_queries:
            self.log(f"Unexpected response ID {message_id}. Ignoring.")
            return

        # Extract query metadata
        query_metadata = self.unresolved_queries.pop(message_id)
        client_addr = query_metadata["client_addr"]
        original_query_id = query_metadata["original_query_id"]
        domain = query_metadata["domain"]
        record_type = query_metadata["record_type"]
        original_query = query_metadata["original_query"]
       #original_domain = original_query.questions[0].qname  # Access the first question in the section

        # Check if the response is authoritative
        cname_records = self.find_records(response.rr, QTYPE.CNAME, domain)
        
        if response.header.aa and len(cname_records) == 0:
            self.log("Authoritative response received. Forwarding to client.")
            self.send_to_client(response, client_addr, original_query_id, original_query)
            return
        elif response.header.aa and len(cname_records) > 0:
            record_type = "CNAME"
            
        # Process response based on the record type
        #Here we get all the A records in the additional section 
        #If there are A records in the additional section WITH THE SPECIFIC DOMAIN, send to client
        #OTHERWISE we go through all the other A Records 
        if record_type == "A":
            self.log("Handling A record.")
            a_records = self.find_records(response.ar, QTYPE.A, domain)
            
            if a_records:
                self.log(f"A records for {domain} found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log(f"No A records for {domain}. Querying next server.")
                self.query_next_server(response, domain, record_type, client_addr, original_query_id, original_query)
                
        #there might be an issue with CNAME records in ANSWER section because we are replacing the ORIGINAL DOMAIN NAME 
        # WITH THE CNAME ALIAS IN THE QUESTION SECTION. So when we send back the RESPONSE to the client, the QUESTION
        # SECTION now has the alias in the Question, not the original domain. I think we need to PRESERVE 
        # the ORIGINAL domian somehow while also using the CNAME name for performing THE DNS QUERY
        
        #THE ABOVE WAS SOLVED BY PASSING THE ORIGINAL QUERY THROUGHOUT THE CALLS TO BE SAVED IN
        #unresolved_queries which could be used to update the Question Section with the appropriate domain
        elif record_type == "CNAME":
            self.log("Handling CNAME record.")
            cname_records = self.find_records(response.rr, QTYPE.CNAME, domain)
            
            if cname_records:
                resolved_name = str(cname_records[0].rdata)
                self.log(f"Resolving CNAME: {domain} -> {resolved_name}")
                self.send_dns_query(resolved_name, "A", self.root_ip, client_addr, original_query_id, original_query)
            else:
                self.log("No CNAME records found. Returning SERVFAIL.")
                self.send_servfail_to_client(domain, record_type, client_addr, original_query_id)

        elif record_type == "MX":
            self.log("Handling MX record.")
            mx_records = self.find_records(response.rr, QTYPE.MX, domain)
            
            if mx_records:
                self.log(" MX records found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log("No MX records found. Querying next server.")
                self.query_next_server(response, domain, record_type, client_addr, original_query_id, original_query)

        elif record_type == "TXT":
            self.log("Handling TXT record.")
            txt_records = self.find_records(response.rr, QTYPE.TXT, domain)
            if txt_records:
                self.log(" TXT records found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log("No TXT records found. Querying next server.")
                self.query_next_server(response, domain, record_type, client_addr, original_query_id, original_query)

        elif record_type == "NS":
            self.log("Handling NS record.")
            ns_records = [record for record in response.auth if record.rtype == QTYPE.NS]
            additional_a_records = [record for record in response.ar if record.rtype == QTYPE.A]
            if ns_records and additional_a_records:
                self.log("NS records with additional A records found. Forwarding to client.")
                self.send_to_client(response, client_addr, original_query_id, original_query)
            else:
                self.log("Resolving NS records to IP addresses.")
                for ns in ns_records:
                    self.send_dns_query(str(ns.rdata), "A", self.root_ip, client_addr, original_query_id, original_query)

        else:
            self.log(f"Unhandled record type {record_type}. Returning SERVFAIL.")
            self.send_servfail_to_client(domain, record_type, client_addr, original_query_id)


    def handle_client_query(self, data, addr):
        """
        Handles requests from clients.
        """
        self.log("Client Query")
        # Parse and handle a client DNS query
        request = DNSRecord.parse(data)
        question = request.questions[0]
        domain = str(question.qname)
        record_type = QTYPE[question.qtype]
        self.log(f"Received query for {domain} (Type: {record_type}) from {addr}")

        if self.check_is_authoritative(domain):
            # Generate an authoritative response
            response = self.record_response(record_type, domain, request)
            response.header.id = request.header.id
            self.log(f"Sending authoritative response to {addr}")
            self.socket.sendto(response.pack(), addr)
        else:
            # Forward query to the root server to resolve an appopriate answer
            self.log(f"Forwarding query for {domain} to root server")
            self.send_dns_query(domain, record_type, self.root_ip, addr, request.header.id)

    
    def recv(self, socket):
        # Handle incoming requests and upstream responses
        data, addr = socket.recvfrom(65535)
        if addr[1] == 60053:
            self.handle_other_DNS_server_response(data)
        else:  # Client query
            self.handle_client_query(data, addr)
            
    def run(self):
        seq = 0
        
        self.load_zone_file()

        while True:
            socks = select.select([self.socket], [], [], 0.1)[0]
            for conn in socks:
                self.recv(conn)

        return

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='send data')
    parser.add_argument('root_ip', type=str, help="The IP address of the root server")
    parser.add_argument('zone', type=str, help="The zone file for this server")
    parser.add_argument('--port', type=int, help="The port this server should bind to", default=0)
    args = parser.parse_args()
    print(f"Root IP:  {args.root_ip}")
    print(f"Zone file provided: {args.zone}")
    sender = Server(args.root_ip, args.zone, args.port)
    sender.run()
